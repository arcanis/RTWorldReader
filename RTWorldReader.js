// Generated by CommonJS Everywhere 0.7.0
(function (global) {
  function require(file, parentModule) {
    if ({}.hasOwnProperty.call(require.cache, file))
      return require.cache[file];
    var resolved = require.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var module$ = {
        id: file,
        require: require,
        filename: file,
        exports: {},
        loaded: false,
        parent: parentModule,
        children: []
      };
    if (parentModule)
      parentModule.children.push(module$);
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    require.cache[file] = module$.exports;
    resolved.call(module$.exports, module$, module$.exports, dirname, file);
    module$.loaded = true;
    return require.cache[file] = module$.exports;
  }
  require.modules = {};
  require.cache = {};
  require.resolve = function (file) {
    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
  };
  require.define = function (file, fn) {
    require.modules[file] = fn;
  };
  var process = function () {
      var cwd = '/';
      return {
        title: 'browser',
        version: 'v0.10.5',
        browser: true,
        env: {},
        argv: [],
        nextTick: global.setImmediate || function (fn) {
          setTimeout(fn, 0);
        },
        cwd: function () {
          return cwd;
        },
        chdir: function (dir) {
          cwd = dir;
        }
      };
    }();
  require.define('/sources/index.js', function (module, exports, __dirname, __filename) {
    var debug = require('/sources/debug.js', module);
    exports.debugMode = debug.debugMode.bind(debug);
    var loaders = require('/sources/loaders.js', module);
    exports.loadBuffer = loaders.loadBuffer.bind(loaders);
    exports.loadUrl = loaders.loadUrl.bind(loaders);
    var tree = require('/sources/tree.js', module);
    exports.Node = tree.Node.bind(tree);
    var three = require('/sources/three.js', module);
    exports.ThreeEntity = three.ThreeEntity.bind(three);
  });
  require.define('/sources/three.js', function (module, exports, __dirname, __filename) {
    var triangulize = function (verticeNodes) {
      switch (verticeNodes.count()) {
      case 3:
        return [verticeNodes];
      case 4:
        return [
          verticeNodes.slice(0, 3),
          verticeNodes.slice(2, 4).prepend(verticeNodes.at(0))
        ];
      default:
        throw new Error('Invalid vertice number');
      }
    };
    var compileGeometry = function (geometryNode, vertexCount) {
      var subfSet = geometryNode.children('FACE').children('SUBF').filter(function (node) {
          return node.children('VCNT').prop('content') === vertexCount;
        });
      var faceCount = subfSet.count();
      var trianglePerFace = vertexCount - 2;
      var triangleCount = faceCount * trianglePerFace;
      var geometry = new THREE.BufferGeometry;
      geometry.attributes = {
        index: {
          itemSize: 1,
          array: new Uint16Array(triangleCount * 3),
          numItems: triangleCount * 3
        },
        position: {
          itemSize: 3,
          array: new Float32Array(triangleCount * 3 * 3),
          numItems: triangleCount * 3 * 3
        },
        normal: {
          itemSize: 3,
          array: new Float32Array(triangleCount * 3 * 3),
          numItems: triangleCount * 3 * 3
        }
      };
      subfSet.forEach(function (faceNode, faceIndex) {
        triangulize(faceNode.children('VERT')).forEach(function (vertices, triangleIndex) {
          vertices.forEach(function (verticeNode, verticeIndex) {
            var firstOffset = function (attribute) {
              return ((faceIndex * 2 + triangleIndex) * 3 + verticeIndex) * attribute.itemSize;
            };
            var vertexData = verticeNode.prop('content');
            var indexOffset = firstOffset(geometry.attributes.index);
            geometry.attributes.index.array[indexOffset] = indexOffset;
            var positionOffset = firstOffset(geometry.attributes.position);
            geometry.attributes.position.array[positionOffset + 0] = vertexData.x;
            geometry.attributes.position.array[positionOffset + 1] = vertexData.y;
            geometry.attributes.position.array[positionOffset + 2] = vertexData.z;
            var normalOffset = firstOffset(geometry.attributes.normal);
            geometry.attributes.normal.array[normalOffset + 0] = vertexData.nx;
            geometry.attributes.normal.array[normalOffset + 1] = vertexData.ny;
            geometry.attributes.normal.array[normalOffset + 2] = vertexData.nz;
          });
        });
      });
      geometry.dynamic = true;
      geometry.offsets = [{
          start: 0,
          count: triangleCount * 3,
          index: 0
        }];
      geometry.computeBoundingSphere();
      return geometry;
    };
    exports.ThreeEntity = function (root) {
      THREE.Object3D.call(this);
      root.children('RTWF').children('WRLD').children('ECHI').children('BRSH').children('IFID').forEach(function (node) {
        var ifid = node.prop('content');
        var geometryData = root.children('RTWF').children('XTRA').children('BGEO').children('BRSH').filter(function (node) {
            return node.children('IFID').prop('content') === ifid;
          });
        if (geometryData.empty())
          return;
        var material = new THREE.MeshLambertMaterial({
            color: 'red',
            wireframe: true,
            side: THREE.DoubleSide
          });
        this.add(new THREE.Mesh(compileGeometry(geometryData, 3), material));
        this.add(new THREE.Mesh(compileGeometry(geometryData, 4), material));
      }, this);
    };
    var F = function () {
    };
    F.prototype = typeof THREE !== 'undefined' ? THREE.Object3D.prototype : {};
    exports.ThreeEntity.prototype = new F;
  });
  require.define('/sources/tree.js', function (module, exports, __dirname, __filename) {
    var Node = function (element) {
      if (element.constructor === Node)
        element = element.array();
      if (element.constructor !== Array)
        element = [element];
      this._set = element;
      this.flatten();
    };
    Node.prototype.empty = function () {
      return this._set.length === 0;
    };
    Node.prototype.count = function () {
      return this._set.length;
    };
    Node.prototype.array = function () {
      return this._set.slice();
    };
    Node.prototype.prop = function (name) {
      return this.get()[name];
    };
    Node.prototype.get = function (n) {
      return this._set[n || 0];
    };
    Node.prototype.at = function (n) {
      return new Node(this.get(n));
    };
    Node.prototype.slice = function (begin, end) {
      return new Node(this._set.slice(begin, end));
    };
    Node.prototype.forEach = function (fn, context) {
      this._set.forEach(function (node, index) {
        fn.call(this, new Node(node), index);
      }, context || this);
      return this;
    };
    Node.prototype.map = function (fn, context) {
      return new Node(this._set.map(function (node, index) {
        return fn.call(this, new Node(node), index);
      }, context || this));
    };
    Node.prototype.filter = function (fn, context) {
      return new Node(this._set.filter(function (node, index) {
        return fn.call(this, new Node(node), index);
      }, context || this));
    };
    Node.prototype.flatten = function () {
      this._set = function recursiveFlattener(chunks, output) {
        chunks.forEach(function (chunk) {
          if (chunk.constructor === Node)
            chunk = chunk.array();
          if (chunk.constructor === Array) {
            recursiveFlattener(chunk, output);
          } else {
            output.push(chunk);
          }
        });
        return output;
      }(this._set, []);
      return this;
    };
    Node.prototype.prepend = function () {
      this._set = [].concat(Array.prototype.map.call(arguments, function (arg) {
        if (arg.constructor === Node)
          arg = arg.array();
        if (arg.construtor !== Array)
          arg = [arg];
        return arg;
      }), this._set);
      return this.flatten();
    };
    Node.prototype.append = function (element) {
      this._set = [].concat(this._set, Array.prototype.map.call(arguments, function (arg) {
        if (arg.constructor === Node)
          arg = arg.array();
        if (arg.construtor !== Array)
          arg = [arg];
        return arg;
      }));
      return this.flatten();
    };
    Node.prototype.children = function (label) {
      return this.filter(function (element) {
        return element.prop('children');
      }).map(function (element) {
        return element.prop('children');
      }).flatten().filter(function (element) {
        return !label || element.prop('label') === label;
      });
    };
    Node.prototype.descendants = function () {
      var set = this.children();
      return set.append(set.map(function (element) {
        return new Node(element).descendants();
      }));
    };
    Node.prototype.find = function () {
      var labels = Array.prototype.slice.call(arguments);
      return this.descendants().filter(function (node) {
        return labels.indexOf[node.prop('label')] !== -1;
      });
    };
    exports.Node = Node;
  });
  require.define('/sources/loaders.js', function (module, exports, __dirname, __filename) {
    var debug = require('/sources/debug.js', module);
    var dictionaries = require('/sources/dictionaries.js', module);
    var parsers = require('/sources/parsers.js', module);
    var tree = require('/sources/tree.js', module);
    var stringify = function (int32) {
      return String.fromCharCode(int32 >> 0 & 255) + String.fromCharCode(int32 >> 8 & 255) + String.fromCharCode(int32 >> 16 & 255) + String.fromCharCode(int32 >> 24 & 255);
    };
    var readChunks = function (stack, dict, dataView) {
      var chunks = [], lastChunk;
      for (var pointer = 0; pointer < dataView.byteLength; pointer += lastChunk.fullSize) {
        var id = dataView.getUint32(pointer, true);
        var label = stringify(id);
        if (id === 0)
          break;
        var size = dataView.getInt32(pointer + 4, true);
        var chunk = lastChunk = {
            id: id,
            label: label,
            size: size,
            fullSize: size + 8,
            content: null
          };
        if (!dict.hasOwnProperty(label)) {
          debug.warning(stack, 'Unrecognized label ' + label);
          continue;
        }
        if (dict[label] && dict[label].constructor === Object) {
          debug.notice(stack, 'Entering label ' + label);
          var subDataView = new DataView(dataView.buffer, dataView.byteOffset + pointer + 8, dataView.byteLength - pointer - 8);
          chunk.children = readChunks(stack.concat([label]), dict[label], subDataView);
          debug.notice(stack, 'Leaving label ' + label);
        } else if (dict[label] && dict[label].constructor === String) {
          chunk.content = parsers[dict[label]](dataView, pointer + 8, size);
          debug.notice(stack, 'Parsing ' + label + ' using ' + dict[label] + ' strategy (gives ' + chunk.content + ')');
        } else {
          debug.notice(stack, 'Registering ' + label + ' data');
          chunk.content = new DataView(dataView.buffer, dataView.byteOffset + pointer + 8, size);
        }
        chunks.push(chunk);
      }
      return chunks;
    };
    exports.loadBuffer = function (buffer, callback) {
      var dataView = new DataView(buffer, 0, buffer.byteLength);
      var chunks = readChunks([], dictionaries.ROOT, dataView);
      callback(null, new tree.Node({ children: chunks }));
    };
    exports.loadUrl = function (url, callback) {
      var xhr = new XMLHttpRequest;
      xhr.open('GET', url, true);
      xhr.responseType = 'arraybuffer';
      xhr.onload = function (event) {
        exports.loadBuffer(xhr.response, callback);
      };
      xhr.send(null);
    };
  });
  require.define('/sources/parsers.js', function (module, exports, __dirname, __filename) {
    exports.signed = function (dataView, offset, length) {
      return dataView['getInt' + length * 8](offset, true);
    };
    exports.unsigned = function (dataView, offset, length) {
      return dataView['getUint' + length * 8](offset, true);
    };
    exports.float = function (dataView, offset, length) {
      return dataView['getFloat' + length * 8](offset, true);
    };
    exports.boolean = function (dataView, offset, length) {
      return dataView.getUint8(offset) !== 0;
    };
    exports.string = function (dataView, offset, length) {
      var utf16 = new ArrayBuffer(length * 2);
      var utf16View = new Uint16Array(utf16);
      for (var i = 0; i < length; ++i)
        utf16View[i] = dataView.getUint8(offset + i);
      return String.fromCharCode.apply(String, utf16View);
    };
    exports.vertice = function (dataView, offset, length) {
      var vertice = {};
      vertice.x = dataView.getFloat64(offset, true);
      offset += 8;
      vertice.y = dataView.getFloat64(offset, true);
      offset += 8;
      vertice.z = dataView.getFloat64(offset, true);
      offset += 8;
      vertice.nx = dataView.getFloat64(offset, true);
      offset += 8;
      vertice.ny = dataView.getFloat64(offset, true);
      offset += 8;
      vertice.nz = dataView.getFloat64(offset, true);
      offset += 8;
      vertice.st = dataView.getFloat64(offset, true);
      offset += 8;
      vertice.tt = dataView.getFloat64(offset, true);
      offset += 8;
      vertice.r = dataView.getFloat64(offset, true);
      offset += 8;
      vertice.g = dataView.getFloat64(offset, true);
      offset += 8;
      vertice.b = dataView.getFloat64(offset, true);
      offset += 8;
      vertice.sl = offset < length ? dataView.getFloat64(offset, true) : null;
      offset += 8;
      vertice.tl = offset < length ? dataView.getFloat64(offset, true) : null;
      offset += 8;
      vertice.toString = function () {
        return JSON.stringify(this);
      };
      return vertice;
    };
  });
  require.define('/sources/dictionaries.js', function (module, exports, __dirname, __filename) {
    exports.ECHI = {
      AENT: { IFID: 'unsigned' },
      BRSH: {
        IFID: 'unsigned',
        TYPE: 'unsigned'
      },
      FACE: {
        IFID: 'unsigned',
        NORX: 'float',
        NORY: 'float',
        NORZ: 'float',
        PLND: 'float',
        TROT: 'float',
        SCAS: 'float',
        SCAT: 'float',
        SHIS: 'float',
        SHIT: 'float',
        COLO: null,
        TEXN: 'string'
      },
      PLGT: {
        IFID: 'unsigned',
        POSX: 'float',
        POSY: 'float',
        POSZ: 'float',
        RADI: 'float',
        COLR: 'float',
        COLG: 'float',
        COLB: 'float'
      },
      UENT: {
        IFID: 'unsigned',
        POSX: 'float',
        POSY: 'float',
        POSZ: 'float',
        NAME: 'string'
      }
    };
    exports.WRLD = {
      IFID: 'unsigned',
      ENAM: 'string',
      HIDE: 'boolean',
      TXPU: 'float',
      NOTS: 'boolean',
      NOTE: 'string',
      LNKS: {
        FRST: 'unsigned',
        SCND: 'unsigned'
      },
      ECHI: exports.ECHI
    };
    exports.XTRA = {
      BGEO: {
        BRSH: {
          IFID: 'unsigned',
          BFCT: 'unsigned',
          FACE: {
            TEXN: 'string',
            SFCT: 'unsigned',
            SUBF: {
              LMID: 'signed',
              VCNT: 'unsigned',
              VERT: 'vertice'
            }
          }
        }
      },
      TEXD: {
        TXTR: {
          TEXN: 'string',
          TWID: 'unsigned',
          THEI: 'unsigned',
          PFMT: 'unsigned',
          DATA: null
        }
      }
    };
    exports.ROOT = {
      RTWF: {
        VRSN: 'unsigned',
        WRLD: exports.WRLD,
        XTRA: exports.XTRA
      }
    };
    exports.ECHI.AENT.ECHI = exports.ECHI;
    exports.ECHI.BRSH.ECHI = { FACE: exports.ECHI.FACE };
  });
  require.define('/sources/debug.js', function (module, exports, __dirname, __filename) {
    var debugMode = false;
    exports.debugMode = function (mode) {
      debugMode = mode;
    };
    var format = function (stack, message) {
      return stack.map(function () {
        return '  ';
      }).join('') + message;
    };
    exports.notice = function (stack, message) {
      debugMode && console.info(format(stack, message));
    };
    exports.warning = function (stack, message) {
      debugMode && console.warn(format(stack, message));
    };
  });
  global.RTWorldReader = require('/sources/index.js');
}.call(this, this));